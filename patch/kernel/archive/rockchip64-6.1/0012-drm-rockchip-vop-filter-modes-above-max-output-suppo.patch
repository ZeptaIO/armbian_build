From a5141661cbcb3881b692805b2b20a6b563402955 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Mon, 20 Jul 2020 11:46:16 +0000
Subject: [PATCH 12/46] drm/rockchip: vop: filter modes above max output
 supported

Filter any mode with a resolution not supported by the VOP.

Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
Signed-off-by: Alex Bee <knaerzche@gmail.com>
---
 drivers/gpu/drm/rockchip/rockchip_drm_vop.c | 48 +++++++++++++++------
 1 file changed, 34 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
index 96833fa83fd3..71bc355f43af 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
@@ -1221,6 +1221,24 @@ static bool vop_crtc_is_tmds(struct drm_crtc *crtc)
 	return false;
 }
 
+static enum drm_mode_status vop_crtc_size_valid(struct drm_crtc *crtc,
+					const struct drm_display_mode *mode)
+{
+	struct vop *vop = to_vop(crtc);
+	const struct vop_rect *max_output = &vop->data->max_output;
+
+	if (max_output->width && max_output->height) {
+		/* only the size of the resulting rect matters */
+		if(drm_mode_validate_size(mode, max_output->width,
+					  max_output->height) != MODE_OK) {
+			return drm_mode_validate_size(mode, max_output->height,
+						      max_output->width);
+		}
+	}
+
+	return MODE_OK;
+}
+
 /*
  * The VESA DMT standard specifies a 0.5% pixel clock frequency tolerance.
  * The CVT spec reuses that tolerance in its examples.
@@ -1234,25 +1252,24 @@ static enum drm_mode_status vop_crtc_mode_valid(struct drm_crtc *crtc,
 	long rounded_rate;
 	long lowest, highest;
 
-	if (!vop_crtc_is_tmds(crtc))
-		return MODE_OK;
-
 	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
-		return MODE_NO_INTERLACE;
+			return MODE_NO_INTERLACE;
 
-	rounded_rate = clk_round_rate(vop->dclk, mode->clock * 1000 + 999);
-	if (rounded_rate < 0)
-		return MODE_NOCLOCK;
+	if (vop_crtc_is_tmds(crtc)) {
+		rounded_rate = clk_round_rate(vop->dclk, mode->clock * 1000 + 999);
+		if (rounded_rate < 0)
+			return MODE_NOCLOCK;
 
-	lowest = mode->clock * (1000 - CLOCK_TOLERANCE_PER_MILLE);
-	if (rounded_rate < lowest)
-		return MODE_CLOCK_LOW;
+		lowest = mode->clock * (1000 - CLOCK_TOLERANCE_PER_MILLE);
+		if (rounded_rate < lowest)
+			return MODE_CLOCK_LOW;
 
-	highest = mode->clock * (1000 + CLOCK_TOLERANCE_PER_MILLE);
-	if (rounded_rate > highest)
-		return MODE_CLOCK_HIGH;
+		highest = mode->clock * (1000 + CLOCK_TOLERANCE_PER_MILLE);
+		if (rounded_rate > highest)
+			return MODE_CLOCK_HIGH;
+	}
 
-	return MODE_OK;
+	return vop_crtc_size_valid(crtc, mode);
 }
 
 static bool vop_crtc_mode_fixup(struct drm_crtc *crtc,
@@ -1262,6 +1279,9 @@ static bool vop_crtc_mode_fixup(struct drm_crtc *crtc,
 	struct vop *vop = to_vop(crtc);
 	unsigned long rate;
 
+	if (vop_crtc_size_valid(crtc, adjusted_mode) != MODE_OK)
+		return false;
+
 	/*
 	 * Clock craziness.
 	 *
-- 
2.34.1

